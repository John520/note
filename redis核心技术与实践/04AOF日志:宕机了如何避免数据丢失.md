# AOF(Append Only File)日志
## AOF写入策略
* Always:每次执行命令后，都将该命令都刷盘写入AOF文件,最多丢失一条命令.主线程会阻塞在刷盘上，性能较差
* No:每次执行命令后，只将命令添加操作系统的文件缓冲区，依赖操作系统的刷盘时间，性能较好
* EverySecond: 每次执行命令后，将命令添加到缓冲区，没过1s将缓冲区的命令刷盘写入AOF文件，性能折中
## AOF文件过大？
* 文件过大，可能导致操作系统无法保存
* 文件过大，每次新的命令写入将变慢，影响性能
* 文件过大，服务重启时恢复数据将变得缓慢
## 减小AOF文件大小（重写AOF:`bgrewriteaof`）
* 从主线程fork一个进程处理重写逻辑（该进程包含主进程的全部数据，如果有修改，通过**写时复制**的方式拷贝内存）
    * fork的瞬间会阻塞主线程
    
## 重写过程有新的请求进来？（一个拷贝（fork），两处复制）
* 将命令写入到原来的AOF文件（缓冲区）
* 将命令写入到子进程（重写AOF进程）的缓冲区，待子进程处理完拷贝后，将缓冲区的数据追加到新的AOF文件中

## 重写时机？
* 手动执行 `bgrewriteaof`
* 配置自动执行：
    * auto-aof-rewrite-percentage 100((当前aof文件大小-上次aof压缩后的文件大小)/上次aof压缩后的文件大小，100表示当前文件已经是上次压缩后文件大小的两倍了，触发rewrite)
    * auto-aof-rewrite-min-size 64M（aof文件大小达到64M之后才会触发）
    上述条件同时满足

##思考
1. 子进程`bgrewriteaof`会阻塞主线程？
    * 写时复制（copy on write）实际是拷贝内存页表（虚拟内存和物理内存的映射索引表），当实例数据量大的时候，拷贝的内存页表就比较多，会有阻塞
    * 操作系统是否开启`huge page`选项（页大小编程2M,原来为4k）。该选项用于提高TLB缓存命中率（由于页大小变大，TLB页表项较少）。
    但是`bgrewriteaof`采用写时复制，若主线程仅修改很小的数据，都需要拷贝2M内存页，然后进行修改。redis机器一般建议关闭该选项
