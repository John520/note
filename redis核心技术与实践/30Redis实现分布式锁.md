
# 基于单节点实现分布式锁
## 加锁
```
SET lock_key unique_value NX PX 10000
```

## 解锁
```lua
if redis.call("get",KEYS[1]) == ARGV[1] 
then 
    return redis.call("del",KEYS[1])
else 
    return 0
end

```

# 基于多节点实现分布式锁`redlock`
假定有N个redis 实例

步骤：
1. 客户端获取当前时间
2. 依次向N个实例加锁
3. 当与所有实例完成加锁，计算整个加锁过程耗时
    * 超过半数实例上获得锁
    * 加锁耗时没超过锁的有效时间
    
    
    
## 单节点分布式锁可靠？
不可靠，当redis节点挂掉，由于主从同步是异步的，如果从节点还未同步，那么将可以再新的主节点上获得锁，
从而导致锁失效（性能好，允许偶尔失效）


## 多节点分布式锁可靠？
加锁过程，客户端发生阻塞或机器时钟跳跃，可能导致失效
* 时钟跳跃
    * 如三个节点的redis 实例
    客户端A 在 1，2 上加锁成功  
    节点2时钟跳跃，导致锁提前释放  
    客户端B 在 2，3 上加锁成功，锁失效
* 客户端阻塞
    * 客户端A 获得锁，但是由于GC/缺页/网络/CPU竞争或其他原因，导致占用锁的时间超过了锁的过期时间
    * 客户端B 接着获得锁。此时锁失效

（可靠性更高，如果要求完全可靠，可以使用zookeeper 或 etcd 强一致性分布式算法来实现）